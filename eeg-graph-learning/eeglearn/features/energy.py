"""A class to compute the band specific energy for each participant.

Created on: April 2025
Author: Udesh Habaraduwa
"""

import math
import os
import random
import time
from itertools import permutations
from multiprocessing import Pool, cpu_count
from pathlib import Path

import numpy as np
import torch
from torch.utils.data import Dataset
from tqdm import tqdm

from eeglearn.config import Config
from eeglearn.features.spectrum import PowerSpectrum
from eeglearn.utils.utils import (
    get_cleaned_data_paths,
    get_labels_dict,
    get_participant_id_condition_from_string,
)


def worker_init_fn(worker_id):
    """Initialize random seed for multiprocessing workers.

    Given the seed management system implemented globally, this function is used
    in the parallel processing of permutations to give a different sequence
    to each process. Otherwise, each process applies and returns the same pseudolabel

    THIS FUNCTION WAS GENERATED BY AI.
    INSPECTEED AND VERIFIED BY AUTHOR.
    """
    seed = os.getpid() + int(time.time() * 1000)
    random.seed(seed)
    np.random.seed(seed % (2**32 - 1)) # Numpy seed must be between 0 and 2**32 - 1
    # If using torch.rand or similar in workers, seed it too:
    torch.manual_seed(seed) 
    torch.cuda.manual_seed_all(seed) # If using GPU


class Energy(Dataset):
    """A class to compute the band specific energy for each participant.

    Methods
    -------
    __init__:
        Initialize the Energy class.
    __len__:
        Return the number of participants in the dataset.
    __getitem__:
        Return the energy for a given participant.
    get_energy:
        Compute the energy for a given participant.
    run_energy_parallel:
        Compute the energy for all participants in parallel.    

    """

    def __init__(self, 
                 cleaned_path : str,
                 select_freq_bands : list[str] = None,
                 save_to_disk : bool = True,
                 energy_plots : bool = False,
                 full_time_series : bool = False,
                 method_psd : str = 'welch',
                 fmin_psd : float = 0.5,
                 fmax_psd : float = 130,
                 tmax_psd : float  = None,
                 picks_psd : list[str] = None,
                 include_bad_channels_psd : bool = True,
                 proj_psd : bool = False, 
                 verbose_psd : bool = False,
                 testing : bool = False,
                 ) -> None:
        """Dataset class for computing and loading energy features from EEG data.

        δ (1-3 Hz)
        θ (4-7 Hz)
        α (8-13 Hz)
        β (14-30 Hz)
        γ (31-50 Hz)

        Args:
        ----
            cleaned_path (str): Path to the cleaned data.
            select_freq_bands (list[str]): List of frequency bands.
            save_to_disk (bool): Whether to save the energy to disk.
            get_labels (bool): Whether to get the labels.
            plots (bool): Whether to plot the energy.
            verbose (bool): Whether to print verbose output.
            full_time_series (bool): Whether to use the full time series.
            method_psd (str): Method to use for PSD computation.
            fmin_psd (float): Minimum frequency for PSD computation.
            fmax_psd (float): Maximum frequency for PSD computation.
            tmax_psd (float): Maximum time for PSD computation.
            picks_psd (list[str]): List of channels to compute the energy for.
            energy_plots (bool): Whether to plot the energy.
            proj_psd (bool): Whether to project the PSD.
            verbose_psd (bool): Whether to print verbose output.
            include_bad_channels_psd (bool): Whether to include bad
              channels in the PSD computation.
            testing (bool) : For when the class is being used during testing.

        """
        self.channel_names: list[str] =  ['Fp1', 'Fp2', 'F7', 
                               'F3', 'Fz', 'F4', 
                               'F8', 'FC3', 'FCz', 
                               'FC4', 'T7', 'C3', 'Cz', 'C4', 'T8', 
                               'CP3', 'CPz', 'CP4', 'P7', 'P3', 'Pz', 
                               'P4', 'P8', 'O1', 'Oz', 'O2']
        self.n_eeg_channels = 26
        # Define all available frequency bands, and the index of the band
        self.all_freq_bands :dict[tuple[list,int]] = {
            'delta': ([1, 3], 0),
            'theta': ([4, 7], 1),
            'alpha': ([8, 13], 2),
            'beta': ([14, 30], 3),
            'gamma': ([31, 50], 4)
        }
        self.cleaned_path : str = cleaned_path
        assert os.path.exists(self.cleaned_path), "cleaned_path does not exist"
        if select_freq_bands is None:
            # this is guaranteed to be in inserstion order
            select_freq_bands : list[str] = list(self.all_freq_bands.keys())
            self.select_freq_bands = select_freq_bands
        else:
            assert isinstance(select_freq_bands, list), \
                "select_freq_bands must be a list"
            assert all(band in self.all_freq_bands for band in select_freq_bands), \
                "Invalid frequency band."
            self.select_freq_bands = select_freq_bands
        
        # get the position in the order of each band
        ordered_bands = [(band,self.all_freq_bands[band][1]) for\
                          band in self.select_freq_bands]
        # get the band names in this order
        self.select_freq_bands : list[str] = [band[0] for band in sorted(ordered_bands,\
                                                      key = lambda x : x[1])]
        
        assert len(self.select_freq_bands) == len(select_freq_bands),\
            "Requested bands and reorderd bands differ in length"
        
        if include_bad_channels_psd:
            assert isinstance(include_bad_channels_psd, bool), \
                "include_bad_channels_psd must be a bool"
            self.include_bad_channels_psd : bool = include_bad_channels_psd
        self.ran_energy : bool = False  
        self.save_to_disk : bool = save_to_disk
        self.energy_plots : bool = energy_plots
        self.full_time_series : bool = full_time_series
        self.method_psd : str = method_psd
        self.fmin_psd : float = fmin_psd
        self.fmax_psd : float = fmax_psd
        self.tmax_psd : float = tmax_psd
        self.picks_psd : list[str] = picks_psd
        self.include_bad_channels_psd : bool = include_bad_channels_psd
        self.proj_psd : bool = proj_psd
        self.participant_list : list[str] = os.listdir(self.cleaned_path)
        assert len(self.participant_list) > 0, "No participants found in cleaned_path"
        self.labels_dict : dict = get_labels_dict()
        assert self.labels_dict is not None, "labels_dict is None"
        self.verbose_psd : bool = verbose_psd

        self.project_root : Path = Path(__file__).resolve().parent.parent.parent
        assert self.project_root.name == \
            'eeg-graph-learning',"project_root is not eeg-graph-learning"
        
        self.plot_save_dir : Path = self.project_root / 'data' / 'energy' / 'plots'
        self.plot_save_dir.mkdir(parents=True, exist_ok=True)
        assert os.path.exists(self.plot_save_dir), "Plotting directory path invalid"
        self.energy_save_dir : Path = self.project_root / 'data' / 'energy' /\
              "energy_full"
        self.energy_save_dir.mkdir(parents=True, exist_ok=True)
        assert os.path.exists(self.energy_save_dir),\
            " Energy save directory path invalid"
        self.energy_save_dir_epoched : Path = self.project_root \
            / 'data' / 'energy' / 'energy_epoched'
        self.energy_save_dir_epoched.mkdir(parents=True, exist_ok=True)
        assert os.path.exists(self.energy_save_dir_epoched), \
            "Energy epoched directory path invalid"
        
        
        # Get the actual number of numpy files to process
        self.folders_and_files : list[tuple[Path, str]] = [] 
        self.participant_npy_files : list[str] = []
        self.folders_and_files, self.participant_npy_files = \
            get_cleaned_data_paths(self.participant_list, self.cleaned_path) 

        self.testing : bool = testing   

        assert len(self.participant_npy_files) > 0,"No .npy files found in cleaned_path"

    def __len__(self):
        """Return the number of EEG data files in the dataset.
        
        Returns
        -------
            int: The number of .npy files across all participant folders.

        """
        return len(self.participant_npy_files)

    def __getitem__(self, idx : int) -> tuple[torch.Tensor, torch.Tensor, str]:
        """Get band energy data for a specific file based on index.
        
        This method computes the band energy data if it hasn't been computed already,
        then returns the data for the file at the specified index.
        
        Args:
        ----
            idx (int): Index of the file in the participant_npy_files list.
            
        Returns:
        -------
            tuple: Contains:
                - torch.Tensor: The band energy data.
                - str: The participant label (if get_labels is True).
                
        Note:
        ----
            If the spectrum file is not found, returns (None, None, None).

        """
        # make sure the spectrum is computed first
        assert self.save_to_disk,\
    "Designed to index by loading. Instantiate energy object with save_to_disk= True"
        if not self.ran_energy:
            self.run_energy_parallel()
        try:
            participant_id, condition =  get_participant_id_condition_from_string\
                (self.participant_npy_files[idx])
            label = self.labels_dict[participant_id]
            if self.full_time_series:
                energy = torch.load(self.energy_save_dir /\
                                      f'energy_{participant_id}_{condition}.pt')
            else:
                energy = torch.load(self.energy_save_dir_epoched /\
                                      f'energy_{participant_id}_{condition}.pt')
            return energy, label
        except IndexError:
            print(f'Energy for {self.participant_npy_files[idx]} not found')
            return None, None, None
        except FileNotFoundError:
            print(f'Energy for {self.participant_npy_files[idx]} not found')
            return None, None, None
    
    def plot_energy(self,):
        """Plot the energy of the EEG data for a given participant."""
        pass

    def get_energy(self, folder_path:  Path, file_name: str) -> torch.Tensor:
        """Compute the energy of the EEG data for one file.

        Args:
        ----
            folder_path (Path): The path to the folder containing the EEG data.
            file_name (str): The name of the file containing the EEG data.

        Returns:
        -------
            np.ndarray: The energy of the EEG data.

        """
        participant_id : str
        condition : str
        participant_id, condition = get_participant_id_condition_from_string(file_name)
        path_to_file : Path = folder_path / file_name
        assert os.path.exists(path_to_file),f"file does not exist: {path_to_file}"

        # # get the spectrum
        spectra : torch.Tensor
        freqs : torch.Tensor
        n_bad_channels : int 
        n_channels_included : int
        spectrum : PowerSpectrum = PowerSpectrum(
                                                cleaned_path=self.cleaned_path,
                                                full_time_series=self.full_time_series,
                                                fmin= \
                                                    self.all_freq_bands['delta'][0][0],
                                                fmax= \
                                                    self.all_freq_bands['gamma'][0][1],
                                                verbose=self.verbose_psd,
                                                picks=self.picks_psd,
                                                include_bad_channels= \
                                                    self.include_bad_channels_psd,
                                                save_to_disk=False)
        spectra, freqs, _, n_bad_channels = spectrum.get_spectrum(
            folder_path=folder_path,
            file_name=file_name,
            save_to_disk=False)
        n_epochs = spectra.shape[0]
        assert not torch.isnan(spectra).any(), "spectra contains nans"
        assert not torch.isnan(freqs).any(), "freqs contains nans"
        n_freqs : int = len(freqs)
        masks : dict = {
            "delta" : (freqs >= 1) & (freqs <= 3),
            "theta" : (freqs >= 4) & (freqs <= 7),
            "alpha" : (freqs >= 8) & (freqs <= 13),
            "beta" :  (freqs >= 14) & (freqs <= 30),
            "gamma" : (freqs >= 31) & (freqs <= 50)
        }
        if self.full_time_series:
            # n_bads either >= 0 , can be 1,2,  --> n _eeg_channels
            # if you are including them in the analysis, then this should not be
            # removed from the included bands
            # if include_bads --> do not subtract
            # if you are Not including, then remove them. 
            # if (not include_bads) --> subtract 
            n_channels_included = self.n_eeg_channels - \
                (1 - self.include_bad_channels_psd)*(n_bad_channels)
            assert spectra.shape[1] == n_freqs, \
                "spectra and freqs have different number of frequencies"
            band_energies : dict = {
                "delta" : torch.sum(spectra[:,masks['delta']], dim = 1),
                "theta" : torch.sum(spectra[:,masks['theta']], dim = 1),
                "alpha" : torch.sum(spectra[:,masks['alpha']], dim = 1),
                "beta"  : torch.sum(spectra[:,masks['beta']], dim = 1),
                "gamma" : torch.sum(spectra[:,masks['gamma']], dim = 1)
            }
            assert band_energies['delta'].shape == \
            band_energies['theta'].shape == \
                band_energies['alpha'].shape == \
                band_energies['beta'].shape == \
                band_energies['gamma'].shape ==  (n_channels_included,), \
                    "Band energies have different shapes"
            # combine the band energies into a single tensor
            # n_channels x n_bands
            selected_bands : list = [band_energies[band] for \
                                      band in self.select_freq_bands]
            combined_energy : torch.Tensor = torch.cat(selected_bands).\
                reshape(n_channels_included,-1)
            assert combined_energy.shape == (n_channels_included, 
                                             len(self.select_freq_bands)), \
                "combined_energy has wrong shape"
            if self.save_to_disk:
                torch.save(combined_energy, self.energy_save_dir /\
                            f"energy_{participant_id}_{condition}.pt")
            return combined_energy
        else:
            n_channels_included = self.n_eeg_channels - \
                (1 - self.include_bad_channels_psd)*(n_bad_channels)
            assert spectra.shape[2] == n_freqs,\
                "spectra and freqs have different number of frequencies"
            # There are 5 matrices of shape (n_epochs x n_channels x n_freq_bins)
            # we collapse the frequency bins dimension by summing it up
            # to get a matrix of (n_epochs x n_channels) for each band      
            band_energies : dict = {
                "delta" : torch.sum(spectra[:,:,masks['delta']], dim = 2),
                "theta" : torch.sum(spectra[:,:,masks['theta']], dim = 2),
                "alpha" : torch.sum(spectra[:,:,masks['alpha']], dim = 2),
                "beta"  : torch.sum(spectra[:,:,masks['beta']], dim = 2),
                "gamma" : torch.sum(spectra[:,:,masks['gamma']], dim = 2)
            }
            #print("band energy : ", band_energies["delta"].shape)
            assert band_energies['delta'].shape == \
            band_energies['theta'].shape == \
                band_energies['alpha'].shape == \
                band_energies['beta'].shape == \
                band_energies['gamma'].shape ==  (n_epochs, n_channels_included), \
                    "Band energies have different shapes"
            
            # a list of len(n_select_freq_bands) n_epochs x n_channels tensors
            selected_bands : list = [band_energies[band] for \
                                      band in self.select_freq_bands]
            # (n_epochs x n_channel x n_bands)
            combined_energy : torch.Tensor = torch.stack(selected_bands,
                                                          dim = 1).permute(0,2,1)
       
            first_band : str = self.select_freq_bands[0]
            # check that the energy for a given band in a given epoch is where it 
            # should be
            assert torch.allclose(combined_energy[0,:,0],
                                  band_energies[first_band][0,:])
            expected_shape : tuple = (n_epochs,
                                      n_channels_included,len(self.select_freq_bands))
            assert combined_energy.shape ==\
                (n_epochs,n_channels_included, len(self.select_freq_bands)),\
            f"{combined_energy.shape} != ({expected_shape})"

            if self.save_to_disk:
                torch.save(combined_energy, self.energy_save_dir_epoched /\
                            f"energy_{participant_id}_{condition}.pt")
            return combined_energy
        

    def run_energy_parallel(self) -> None | list:
        """ 
        Compute band energy for all participants and conditions in parallel.
        
        It uses the get_energy method for individual
        file processing and uses a process pool to distribute the workload.
        
        The method sets ran_energy to True to indicate that energy computation has 
        been performed, to make sure when called by __getitem__ it does not compute
        the energy again.

        Args:
        ----
            None

        Returns:
        -------
            None : if saved to disk
            list : List of energy matrices

        """
        self.ran_energy = True
        processes = cpu_count() - 1
        print(f'Using {processes} processes for energy computation')
        with Pool(processes) as p:
            results : list[torch.Tensor] = \
                list(tqdm(p.starmap(self.get_energy, self.folders_and_files), 
                     total=len(self.folders_and_files), 
                     desc="Computing Energy bands"))
            if not self.save_to_disk:
                return results
            
    def get_freq_permutations(self, data : torch.Tensor = None,
                         is_epoched : bool = False,
                         file_name : str = None) -> tuple[torch.Tensor,int]:
        """Get all the frequency band permutations of the data.
        
        Takes a (n_epochs x n_channels x n_bands) or (n_channels x n_bands ) energy
        matrix and generates a permutation of the bands. 

        Args:
        ----
            data (torch.Tensor): A (optionally n_epochs) x n_channels x n_bands tensor.
            file_name : File name containing participant id and condition ending in
                        .pt.
            is_epoched : If the incoming data is epoched.

        Returns:
        -------
            tuple: Contains:
                - torch.Tensor: The permuted data.
                - int: The pseudolabel representing which permutation was applied.

        """
        if data is None:
            if is_epoched:
                data = torch.load(self.energy_save_dir_epoched / file_name)
            else:
                data = torch.load(self.energy_save_dir / file_name)
        assert isinstance(data, torch.Tensor)
        # Assert shape for non-epoched and epoched cases
        assert len(data.shape) >=2 or len(data.shape) <= 3
        is_epoched = True if len(data.shape)==3 else False
        band_position : dict = {band : i for i, band \
                                in enumerate(self.select_freq_bands)}
        
        possible_perms : dict[int, tuple[str, ...]] =\
            dict(enumerate(permutations(self.select_freq_bands)))
         
        pseudo_label : int = random.randint(0,
                                            math.factorial(len(self.select_freq_bands))\
                                                -1)
        band_ordering : list[int] = [band_position[band]\
                                      for band in possible_perms[pseudo_label]]
        
        if is_epoched:
            try:
                shuffled_columns : torch.Tensor = data[:,:,band_ordering]
            except IndexError as err:
                raise IndexError("A mismatch between expected bands. "
                                 "Usually a result of having run test_energy.py. "
                                 "Delete the energy folder in data and retry.") from \
                                 err
            assert shuffled_columns.shape == data.shape
            if file_name:
                self.perm_save_dir : Path = self.project_root /\
                  'data' / 'energy' / 'epoched_perms'
                self.perm_save_dir.mkdir(parents=True, exist_ok=True)
                assert os.path.exists(self.perm_save_dir),\
                    "Permutation save directory path invalid"
                
                save_path = self.perm_save_dir / f"energy_perms_{file_name}"
                torch.save((shuffled_columns, pseudo_label), save_path)
                assert os.path.exists(save_path),\
                    f"Data file does not exist: {save_path}"
        else:
            try:
                shuffled_columns : torch.Tensor = data[:,band_ordering]
            except IndexError as err:
                raise IndexError("A mismatch between expected bands. "
                                 "Usually a result of having run test_energy.py. "
                                 "Delete the energy folder in data and retry.") from \
                                 err
            assert shuffled_columns.shape == data.shape
            if file_name:
                self.perm_save_dir : Path = self.project_root /\
                  'data' / 'energy' / 'perms' 
                self.perm_save_dir.mkdir(parents=True, exist_ok=True)
                assert os.path.exists(self.perm_save_dir),\
                    "Permutation save directory path invalid"
                save_path = self.perm_save_dir / f"energy_perms_{file_name}"
                torch.save((shuffled_columns, pseudo_label), save_path)
                assert os.path.exists(save_path),\
                    f"Data file does not exist: {save_path}"
        return (shuffled_columns,pseudo_label, file_name) 
    
    def run_permutations_parallel(self)-> None | list:
        """Compute band energy permutations for all files in parallel.

        Uses unique random seeds for each worker.

        It uses the get_permutaion method for individual
        file processing and uses a process pool to distribute the workload.

        Args:
        ----
            None

        Returns:
        -------
            None : if saved to disk
            list : List of permutations for each energy matrix

        NOTE: Problem with sending multiple arguments to starmap solved with AI

        """
        starmap_args = []

        # Files from energy_save_dir are NOT epoched
        full_length_energy_files = os.listdir(self.energy_save_dir)
        print("full len :",len(full_length_energy_files))
        for filename in full_length_energy_files:
            starmap_args.append((None, False, filename))

        # Files from energy_save_dir_epoched ARE epoched
        epoched_energy_files = os.listdir(self.energy_save_dir_epoched)
        for filename in epoched_energy_files:
            starmap_args.append((None, True, filename))
            
        print("epoched :",len(epoched_energy_files))
        processes = cpu_count() - 1
        print(f'Using {processes} processes for energy permutation computation')
        print(f"Processing {len(starmap_args)} files...")

        # This is the same as except does not use the correction for starting
        # each new process with a diffeent seed. It is used for testing.
        if self.testing:
            with Pool(processes) as p:
                results = list(tqdm(p.starmap(self.get_freq_permutations, starmap_args),
                                    total=len(starmap_args),
                                    desc="Computing energy band permutations"))
        else:
            with Pool(processes, initializer=worker_init_fn, initargs=(os.getpid(),)) \
                as p:
                results = list(tqdm(p.starmap(self.get_freq_permutations, starmap_args),
                                    total=len(starmap_args),
                                    desc="Computing energy band permutations"))

        print(f"Finished processing {len(results)} permutations.")

        return results

if __name__ == "__main__":
    # Set seed for reproducibility
    Config.set_global_seed()
    
    cleaned_path = Path(__file__).resolve().parent.parent.parent / 'data' / 'cleaned'
    labels_file = Path(__file__).resolve().parent.parent.parent / 'data' / \
        'TDBRAIN_participants_V2.xlsx'
    dataset = Energy(cleaned_path=cleaned_path,
                     full_time_series=False,
                          energy_plots=True,
                          verbose_psd=False,
                          picks_psd = ['eeg'],
                          include_bad_channels_psd=True,
                          save_to_disk=True,
                          select_freq_bands=['gamma', 'delta','beta'])
    print(len(dataset))
    #files = dataset.run_energy_parallel()
    #print(len(files))
    print(dataset[0][0].shape)
    # for data in dataset:
    #     #print(data[1])
    #     dataset.get_permutations(data[0])
    # #print(dataset.get_permutations(dataset[0][0])[0].shape)
    results = dataset.run_permutations_parallel()
    # for data, label, file_name in results:
    #     print(file_name, label)
    